# 研究生周报（第十一周）

## 学习目标

1. 自编码器
2. 表示学习
3. 多任务学习
4. 信息检索导论

## 学习时间

> 7.17~1.23

## 学习产出

1. [Python代码](./code/)
2. github记录

### 自编码器

自编码器（autoencoder）是神经网络的一种，经过训练后能尝试输入复制到输出。
自编码器（autoencoder）内部有一个隐藏层，可以产生编码（code）标识输入。

1. 欠完备自编码器
   从自编码器获得有用特征的一种方法市限制h的维度比x小，这种编码维度小于输入维度的自编码器成为欠完备（undercomplete）自编码器。
   如果编码器和解码器被赋予过大的容量，自编码器会执行复制任务而捕捉不到任何有关数据分布的有用信息。
2. 正则自编码器
   编码维数小于输入维数的欠完备自编码器可以学习数据分布最显著的特征。
   正则自编码器可以根据建模的数据分布的复杂性，选择合适的编码维数和编码器、解码器容量，就可以成功训练任意架构的自编码器。
   1. 稀疏自编码器
      稀疏自编码器简单地在训练时结合编码层地稀疏惩罚$\Omega(h)$和重构误差
      $$L(x,g(f(x)))+\Omega(h)$$
      其中$g(h)$是编码器的输出，通常$h$是编码器的输出，即$h=f(x)$
      稀疏自编码器一般用来学习特征，以便用于像分类这样的任务
   2. 去噪自编码器（denosing autoencoder,DAE）
      $$L(x,g(f(\hat{x})))$$
      其中$\hat{x}$是被某种噪声损坏的x的副本，因此去噪自编码器必须撤销这些损坏，而不是简单得复制输入。
   3. 惩罚导数作为正则（收缩自编码器）
      这个惩罚只对训练数据适用，它迫使自编码器学习可以反应训练数据分布信息的特征。
3. 表示能力、层的大小和深度
   训练深度自编码器的普遍策略是训练一堆浅层的自编码器来贪心地预测训练相应的深度架构。所以即使最终目标是训练深度自编码器，我们也经常会遇到浅层自编码器。 
4. 随机编码器和解码器
   随机编码器本质上是一个前馈网络，可以使用与传统前馈网络相同的损失函数和输出单元。
5. 收缩自编码器
   收缩自编码器在编码$h=f(x)$的基础上添加了显式的正则项，鼓励$f$的导数尽可能小：
   $$\Omega(h)=\lambda||\frac{\partial{f(x)}}{\partial{x}}||_F^2$$
   惩罚项$\Omega(h)$为平方Frobenius范数（元素平方之和），作用与与编码器的函数相关偏导数的Jacobian矩阵。
   去噪自编码器能抵抗小而有限的输入扰动，而收缩自编码器使特征提取函数能抵抗极小的输入扰动。
6. 自编码器的应用
   1. 降维
   2. 学习检索任务：找出数据库中类似的条目

### 表示学习

表示学习提高了进行无监督学习和半监督学习的一种方法。

1. 贪心逐层无监督预训练
   无监督学习在深度神经网络的复兴起到了关键的、历史性的作用，它使研究者首次可以训练不含诸如卷积或者循环这类特殊结构的深度监督网络。我们将这一过程成为无监督预训练，或者更精确地，贪心逐层无监督预训练。
   贪心贪婪训练法主要思路就是每次只训练神经网络中的一层，先训练一个只含一个隐藏层的，当该层训练结束之后才开始训练一个有两个隐藏层的网络，以此类推。
   在每一步训练中，把已经训练好的前k-1层固定，然后增加第k层，前面的就是k层的输入。每一层的训练可以是有监督的，更通常适应是无监督方法，如：自动编码器。
   这些单层训练所得到的权重被用来初始化最终网络的权重，然后对整个网络进行微调。
2. 迁移学习和领域自适应
   迁移学习和领域自使用指的是利用一个情景中已经学到的内容去改善另一个情景中的泛化情况。
   1. 在迁移学习（transfer learning）中，学习器必须执行两个或者更多个不同的任务，但是我们假设能够解释$P_1$变化的许多因素和学习$p_2$需要抓住的变化相关。
   2. 迁移学习的两种极端形式是一次学习和零次学习。只有一个标注样本的迁移任务被称为一次学习；没有标注样本的迁移任务被称为零次学习。
      1. 因为第一阶段学习出的表示就可以清楚地分离出潜在地类别，所以一次学习是可能地。
      2. 零次学习地示例：学习器读取了大量文本，然后解决对象识别地问题。
3. 半监督解释因果关系
   一种假设是：理想表示中地特征对应到观测数据地潜在成因，特征空间中不同地特征或方向对应着不同地原因，从而表示能够区分这些原因。
   即，如果y是x地重要称因，那么表示p(x)也可能是计算p(y|x)的一种良好表示。
4. 分布式表示
   分布式表示的概念（由很多元素组合的表示，这些元素之间可以设置成可分离）是表示学习最重要的工具之一。
   分布式表示非常强大，因为它们能用具有k个值的n个特征去描述$k^n$个不同的概念。

### 多任务学习

制作模型时关注一个特定指标的优化，比点击率模型，就优化AUC,做二分类模型，就优化f-score。然而，这样忽视了模型通过学习其他任务所能带来的信息增益和效果上的提升，通过在不同任务中共享向量表达就能够让模型在各个任务上的泛化效果大大提升，这就是多任务学习（MTL）

1. MTL的两个方法
   1. hard parameter sharing
   前几个DNN为各个任务共享，后面分离出不同任务的layers。
   这种方法有效降低了过拟合的风险：模型同时学习的任务数越多，模型在共享层就要学到一个通用的嵌入式表达使得每个任务都表现叫好，从而降低过拟合的风险。
   2. soft parameter sharing
   每个任务都有自己的模型，有自己的参数，但是对不同模型之间的参数是有限制的，不同模型的参数之间必须相似，因此会有个distance描述参数之间的相似度，会作为额外的任务加入到模型的学习中，类似正则项。
2. 多任务学习提效的原因
   1. 隐式数据增强：模型的样本量会提升很多，可以忽视噪声。
   2. 注意力聚焦：噪声多、数据少且高维的情况下多任务学习可以帮助模型聚焦到有用的特征上。
   3. 特征信息窃取：可以高效的学习每一个重要的特征。
   4. 表达偏差：使得模型学到的所有任务都偏好的向量表示。
   5. 正则化：对一个任务，其它任务的学习对它有正则化效果。
3. 多任务学习模型
   1. Deep Relationship Networks。卷积层前几层用于预训练，后几层共享参数，最后DNN模块学习各个任务。
   2. Fully-Adaptive Feature Sharing。从一个简单的网络开始，贪婪地扩展网路，并且每个分支只给一个任务
   3. cross-stitch Networks。完全分离的模型结构，使用cross-stitch单元学习不同任务之间的关系。
   4. A Joint Many-Task Model。预定义的层级结构有各个NLP任务组成，不同层级的结构进行不同任务。
   5. weighting losses with uncertainty。考虑不同任务之间相关性的不确定型，调整每个任务在成本函数中的相对权重。
   6. sluice networks、ESSM、DUPN、MMOE、PLE。

### [信息检索导论](../信息检索导论/README.md)

1. 布尔检索
2. 词项词典及倒排记录表
3. 词典及容错式检索
4. 索引构建
5. 索引压缩
6. 文档评分、词项权重计算及向量空间模型
7. 一个完整搜索系统中的评分计算
8. 相关反馈及查询的扩展
9. 概率检索模型

## 总结

1. 本周学习了深度学习花书的自编码器和表示学习，继续看来吴恩达的课程，发现之前只看书不理解的一些内容通过看视频却明白了；看了信息检索导论的一些内容，只看了前十章的大概，目前感觉和要做的东西联系好像不是非常紧密，可能在项目的错字上面有用吧。
2. 下周继续看深度学习花书的后续内容，信息检索导论的内容也继续看下去。
